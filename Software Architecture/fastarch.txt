----Write Up for fastkwic.py------------


In this assignment, I decided to take the professor’s implementation of kwic and try and use that as my basis for fastkwic. I began by first going through his implementation and commenting it so I could understand his process of how he got to where it is. This allowed me to gain a better understanding of a version of the program that actually works fully to the standard of the last assignment. After that was completed as I say in my write up for testability I split up all the functions so it would work well with my testing functions and assert each one properly. For fastkwic i decided to continue off of this build. I read through various articles and readings that suggested how to improve performance. By managing resources and its demands it gave me an idea how to significantly reduce the time it takes to read a text file. I decided to implement multiprocessing in my fastkwic which would increase the efficiency and speed up the time taken to read the text file. This would help with concurrency both locally and remotely and allow me to use multiple processors instead of threads which use analogs which make it much different and in turn faster for the program. The assignment as stated in the requirements is barely software architecture, but is enough to implement a process that will significantly improve performance. By bringing in multiprocessing and processing at the top it creates a project then calls the p.start() and then is finished with the p.join(). The heaviest function in the program was the one that created pairs so, I decided to implement multiprocessing in that function. By calling previous arguments and targeting them with the multi process, this resulted in the create pairs having targets of by using splitline and pairs arguments. The software while simple enough to code into a few lines, benefited the program and took a while of understanding and reading before I could properly implement it without affecting other parts of the program which would then give inaccurate run times. For example one of my earlier iterations of multi process caused the pairs creation to not work and thus outputting a time so quickly for both ulysses and qualities that didn’t seem accurate. Once I fixed the errors it gave me significantly better processing time. With the original kwic it took 2.9 to 3 seconds to run a qualities.txt I made that was around 56kb. The reason for making this was to have something that stood in the middle of the original qualities which went by rapidly and ulysses would take around half hour. After finishing the multiprocessing I would result in times of around 2.3 to 2.4 seconds to read the qualities text file, which is a 30 percent increase in performance. This process was able to really help understand software architecture and how to go through the process of taking a given project and optimizing it so it can not only perform better but also be able to test itself to make sure all the components run properly and give the correct outputs. The thing I liked about this kwic was that that it was already very optimized so it wasn’t like I was working with a very slow piece of software and then had to do many small and simple tasks to make it faster, but rather already have a somewhat efficient program and then implement a whole idea that makes it faster and improves the overall architecture of the program.