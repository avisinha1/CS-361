The goal of the assignment is to have a kwic and associated finite state machine file that allows for incremental indexing as well as meeting the criteria of the previous assignments. The finite state machine as explained in the assignment requirements helps us with the design. The finite state machine consists of a number of states and each state changes based on the current state and input symbol. The entire history of the machine is summarized in the current state. The main point of finite state machines is that it is practical, for example a communications protocol like a USB  will show what will happen based on the previous outputs. Finite state machines also helpful with problem solving. By setting up an array or data structure that stores the state.  The processes in kwic.fsm essentially starting, then the exit state is that kwic being constructed and call the PreInput. It then stays in the state until an addtext is called which processes through. The next state consists of a string that hasn’t been indexed or paired. After this it is indexed but hasn’t been called yet. By this state the ListPairs has been activated but not yet been indexed, through errorhandling this then becomes indexed and has called the listPairs. This fsm file lists off the entire process that kwic.py goes through to when it acess the test event file, it can properly output values. Originally we were given a testevenspec.py that accessed machine.fsm, but in the case of this assignment I had to recreate testeventspec to access the kwic fsm file. To do this i followed the format of the original test event spec but instead used the code given to us by Alex in the assignment description and then had given texts be printed when run through kwic. The event spec we were given runs various functions, but one of the important ones is the printlog functions which show the step of the test and then shows whether its in the state of “e” or “s”. Inside kwic.py I took what I had last time and imported the event spec and called in the finite state machine. Kwic stays the same but instead becomes a class and runs all the same processes as before. Essentially all these files are linked through the fsm file and then called through the event specs and then output the values correctly. The similar functions of breaking text, getting pairs, shifting lines, flattening lines, filtering lines, listing pairs are all carried through from the previous assignment, which both helped my understanding of FSM and made it the project easier to work on as I already had a place to start from. Overall I like finite state machines, it is helping with my understanding of the theory of computation. The simplicity or complexity of a sequence in a FSM directly affects how complex it will be as a whole. FSMs can be be developed even more by the use of a stack based FSM which uses a stack to control the states and the transitions are handled by using pops and push mechanisms. This removes the need for an activestate because the top of the stack will already be in play. This assignment essentially took what we already had from previous iterations of kwic and implement a way to systemize what occurs and keep tracks of the state it goes through.